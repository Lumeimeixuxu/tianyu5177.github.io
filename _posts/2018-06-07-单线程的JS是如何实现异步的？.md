---
layout: post
title: "单线程的JS是如何实现异步的？(JS事件轮询机制)"
date: 2018-06-05
description: "JavaScript，前端"
tag: JS高级 
--- 
### **1. 单线程还能异步，好像有点矛盾呢？**
**前言：**	

> &emsp;对于js，它是单线程的，但同时又能完成异步的处理（如ajax请求，开启定时器任务等），这很矛盾啊！只有一个进程，怎么做到异步的？或者说，如果在主进程之外还存在其他线程去处理异步任务，那么就不能说它是单线程了啊？js选择了成为单线程的语言，所以它本身不可能是异步的，如何完成异步的，我们慢慢探讨。

<br>

### **2. 先来明确：什么是单线程？**

>《计算机组成原理》书中是这样定义线程和单线程的：

> 1. **进程**是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源。
> 2. **单线程**在程序执行时，所走的程序路径按照连续的顺序排下来，前面的程序必须处理完毕，后面的程序才会执行。

&emsp;举个例子：单线程就是一位**“用情专一”**的小伙子，看不到女神的微笑我是不会作别的事情的，一直等待。

### **3. JS真的这么“专一”吗？**	
&emsp;老生常谈的一个例子，下面代码，控制台结果如下：

	 setTimeout(function () {
	        console.log("我是输出1，1000毫秒过去了，我执行了！");
	    },1000);
	
	 console.log("我是输出2，我要排队，我会在输出1执行完毕后输出");
	 
	 /*		
	  结果如下：
	  我是输出2，我在输出1后执行的！
	  我是输出1，1000毫秒过去了，我执行了！
	 */
	 
&emsp;明显输出1没有傻傻的等着定时器，JS执行时并没有那么“专一”。需要等待的你就等待，到时间再执行，不需要等待的，优先执行。

### **4. 不矛盾，是你的浏览器帮助了JS**

> &emsp;1. js代码的运行环境，主要就是：浏览器端（客户端），Node.js等其他js引擎（服务端），也就是说js代码要依托它的宿主平台，就如同java代码要运行，脱离不开JDK环境的支持一样。

> &emsp;2. js是单线程语言，严格的按照定义去理解就是：js在运行时候只会有js一个线程，用来执行任务（函数），但一次只能执行一个任务，这些任务形成一个任务队列排队等候执行。但是如果真的就这样去做了，就会导致：当执行非常耗时的任务时，比如网络请求，上面例子中的定时器或者事件监听，执行效率会非常的低，甚至导致页面的假死。

> &emsp;3. 为了提高处理效率，也为了更好的将网页展示给用户，**浏览器为这些耗时任务开辟了另外的线程！**，主要包括http请求线程，浏览器定时触发器，浏览器事件触发线程，这些任务是异步的。

<br>
**这里，敲黑板了！！！**

* **所以说，本文开头的那个矛盾，根本不存在，js一直是都是单线程的，它就是门单线程的语言，不会像其他语言那样为了效率自己去创建进程，然后自己再去协调各个进程之间的配合，js要是这样做，对于这个脚本语言来说就太复杂了，例如涉及到多个线程同时操作DOM，就要协调好顺序，这样js就太“重”了！失去了轻量化脚本语言的意义。**

* **你的浏览器（或者是Node.js等其他JS的宿主环境）才是真正实现异步的那个家伙！浏览器针对JS的语言特性，对那些可能会造成高延迟的事件（网络请求、事件侦听等）开了辅助进程（），将那些高延迟的甩给这些进程，所以我们总说，js有个主进程。一句话概括就是：浏览器为js的特殊方法，开启了特殊的辅助进程。**

### **5. 浏览器端的Event Loop（事件轮询）机制**
&emsp;本文只讨论浏览器的事件轮询，因为其他js宿主环境（例如Node）与浏览器有较大差异，其他文章再做讨论。

&emsp;来吧，这个经典的小图：
![](http://oi5hiw2r7.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B.png)

> 1. 所有任务都在主线程上等待执行，这就是“执行栈”，当遇到可能带来高延迟的任务（这个任务一般包括：网络请求、定时器、侦听事件等）时，将任务交给该任务的事件管理器（辅助进程）这就是异步操作。这里要注意的是，当遇到定时器，会立刻把定时器加入定时器管理模块，但是不会马上计时，要等主线程（执行栈）任务全部执行完毕，才会开始计时。
> 2. 主线程继续操作其他任务，当异步任务有了结果，就在"任务队列"之中放置异步任务对应的回调函数。	
> 3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。	
> 4. 主线程不断重复上面的第三步。

<br>
&emsp;**对于浏览器端来说，异步就是为了带来更好的体验，尽量不让高延迟的任务去阻塞主线程，带来流畅体验。**